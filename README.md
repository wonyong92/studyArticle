## 1. 자바와 절차적/구조적 프로그래밍

- 구조적 프로그래밍 유산 → 함수 중심의 프로그래밍 → 메소드로 코드 재사용 및 중복 제거
    - 함수 vs 메소드
        - 공통점 = 연산들의 모음
        - 차이점
            - 함수 = 독립적인 요소. C언어의 함수는 언제든지 호출되고 수행된다.
            - 메소드 = 객체에 종속적인 요소. 객체를 통해서만 호출되고 수행된다.
- 절차적 프로그래밍 유산 → 코드 실행 순서의 변경을 방지(goto 막음)
    - ⇒ C 언어는 구조적 언어이면서, 절차적 언어(이긴 한데 goto가…)이다.
    - ⇒ 자바는 C언어의 구조적,절차적 요소 위에 메모리 영역의 분리를 통한 객체라는 단위로 동작의 관리 및 프로그램 구조를 설계.
- 전처리 과정 : 스태틱 영역 - 클래스에서 선언되는 정적 변수(클래스 멤버 변수), 메소드 선언 정보들의 저장소. → 프로그램 실행과 동시에 변수 초기화 → 힙에 객체 생성
- 메소드 수행 과정 : 스택 영역에 메서드 수행에 필요한 데이터(지역 변수)들을 할당 → 디버거로 내부 스택의 상태를 짐작해 볼 수 있다.
- 메소드 스택 내부의 새로운 스택 → 메소드 내부에서 만나는 새로운 메소드들에 대해서는 진행 중이던 스택 내부에 새로운 내부 스택을 생성하여 내부 메소드 수행
- 서로 다른 메소드 호출 → 전체 스택 영역에 서로 다른 스택 영역 생성 → 서로 확인 불가능
- 메소드들의 공유 데이터 = 전역 변수 → 기껏 분리하여 캡슐화된 메소드들 사이에 연결점 생성⇒ 변화를 추적하는 과정이 매우 피곤해진다.
- 스태틱 영역에 저장되는 데이터 ⇒ 전역 변수 = “클래스” 멤버 정보, 정적 변수 ↔ 스택에 저장되는 데이터 ⇒ 지역 변수 = “인스턴스(객체)” 주소 정보, 동적(으로 메모리에 생성되고 해제되는) 변수
    - ⇒ 객체와 분리되어도 되거나(스태틱 메서드에서는 특정 상태를 이용하지 못,안한다) 공통으로 필요로 하는 상태 값(전역 변수)에 대해서는 적절하게 사용하도록 한다.
- 스레드 → 스택 영역에 스레드를 위한 메모리 구조를 생성 → 스태틱 및 힙 영역은 공유 : 객체들과 정적 변수들에 대해 공유 상태 ⇒ 락을 사용하면 안전하게 데이터 공유가 가능하지만 그렇게 쓸거면 스레드 쓰지마라…

---

## 2. 객체 지향

- 객체지향의 큰 그림
    - 객체 지향 프로그램은 객체로 구성되고 객체들간의 관계로 구조가 성립한다.
    - 객체는 고유하다.
    - 각 객체는 상태와 동작을 소유한다.
    - 객체는 자신의 상태에 따라 자율적으로 동작을 수행한다.
    - 클래스 객체의 분류 방법 → 객체의 큰 특징을 분류. 타입으로 사용된다.
    - 실제로 고유한 것은 객체의 스냅샷인 인스턴스이다.
- 객체지향 4대 “특성”
    - 추상화
        - 객체지향 패러다임은 모든 것을 추상화하여 사용한다..
            - 유효하면서 공통적이고 고유한 특성을 추려내어 특정 대상을 구별 할 수 있도록 한다.
                - 유효한 특성을 판단하는 기준 ⇒ 프로그램의 최종 목표 ⇒ 관심 영역 = 어플리케이션 경계
                - 추상화 = 어플리케이션 경계에 맞추어 대상을 모델링하는 것.
            - 추상화 결과 → 클래스로 불리는 구별을 위한 데이터 모음을 정의 가능. 특별히 다른 대상과 구별되는 내용만을 모았기에 “타입”으로도 부른다.
            - 고유한 특성들 → 특성들의 조합 발생 ⇒ 특정 시점의 특정 클래스(타입)에 대한 특성 값의 모음 = 인스턴스
            - 정상적인 인스턴스의 생성 과정 → 클래스의 정의 → 클래스에 대한 특정 상태 값들을 정의 → 인스턴스화(생성자를 통해 메모리에 할당) → 인스턴스 생성
            - 비정상적인 인스턴스의 생성과정 → 직렬화 데이터(바이트코드)에서 특정 상태 값 읽기 및 클래스 구조 읽어 바로 메모리에 할당 → 인스턴스 생성. = 정말 위험한 동작. 성공 여부도 불확실함.(단순히 메모리 덤프 데이터를 바로 현재 메모리에 할당하는 방식)
            - 비정상적인 인스턴스의 생성과정 2 → 리플렉션을 통한 메소드 추출 → 생성자를 추출하여 강제로 수행 → 인스턴스화 → 인스턴스 생성. = 그나마 어느정도 정상 참작 가능
            - 인스턴스(객체의 스냅샷)는 힙 영역에 저장되고, 스택의 변수에 해당 힙 영역 주소를 저장하여 스택을 통해 접근이 이루어진다.
            - 스택 영역을 통해 더이상 참조되지 않는 힙영역(인스턴스)는 가비지 컬렉터의 제거 대상이 된다.(바로 제거되는 것이 아니다)
            - 
            
    - 캡슐화
        - 자바의 객체(인스턴스)는 서로 독립된 메모리를 영역을 가진다 → 다른 객체의 멤버를 이용하기 위해서는 해당 객체의 주소를 필요로 한다
            - → 내부에 해당 객체를 생성하여 주소를 알아낸 후 사용 가능
            - → 메소드의 파라미터(pass by value - heap memory address value)를 통해 해당 객체의 주소를 알아낸 후 사용 가능
        - 생성되어 버린 객체는 요청 생성 자체에 대해서는 아무 권한이 없다 → 응답에 대한 권한은 보유할 수 있다 → 접근 제어자
    - 상속
        - 재사용과 확장을 위한 장치
        - 구현 - 타입을 추상화(인터페이스)하여 서브 객체가 구현을 통해 인터페이스라는 큰 틀을 만족하도록 제한하는 것. ⇒ 여러 객체에 대해 타입에 대한 공통 분모(인터페이스) 생성
        - 확장 - 수퍼 클래스의 내용을 서브 객체가 재사용 그리고 서브 객체 자체의 기능을 보유하는 것. ⇒ 동작과, 상태에 대한 공통 분모 생성.
            - 수퍼 객체가 서브 객체 보다 작은 영역을 가진다 → 수퍼 객체의 scope는 자신으로 한정, 서브 객체의 scope는 수퍼 객체까지 확장 된다. → 서브 클래스의 생성자 호출 시 반드시 혹은 자동으로 수퍼타입의 생성자를 호출해야만 하는 이유.
        - 둘 다 상위 클래스/인터페이스에 대해 모든 내용을 구현 혹은 포함하고 있으므로 상위 타입 객체를 대체 할 수 있다.
        - 대체는 할 수 있지만 동일한 것은 아니다. → kind of 관계(extends - 상위 객체의 동작과 상태를 포함하고 있으면서 다른 동작과 상태를 가질 수 있다.) or be able to 관계(implements - 인터페이스에 정의된 행동을 할 수 있다.)
        - 서브 객체가 인스턴스화 되어 힙 메모리에 할당 될 때 해당 서브 객체를 위한 수퍼 객체 또한 연결된 상태로 힙 영역에 생성되어 서브 객체에 대해 수퍼 객체의 데이터 참조 요청 시 서브 객체에서 구현하는 내용이 없다면 자동으로 수퍼 객체로 이동하여 요청을 처리한다. → 다중 상속이 불가능한 이유. 수평적으로 상속된 객체들이 많으면 찾으러 가기가 너무 힘들고, 중복으로 인하여 접근이 모호해 질 수 있다.
        - 변수 → 힙 메모리 접근 창구
            - ⇒ 서브 타입 변수로 접근 → 서브 객체로 일단 접근 → 필요한 데이터가 없다면 상위 객체로 이동하여 접근.
            - ⇒ 상위 타입 변수로 접근 → 상속은 객체가 아닌 클래스에 대해 수행되는 것으로 즉 상위 객체 단독 생성 시 서브 객체가 논리적으로 존재 자체가 불가능 → 서브 타입 객체가 할당된 경우에는 상위 타입에 대해 접근 수행. 오버라이딩 되어있는 메소드의 경우 이미 하나로 묶여 있으므로 서브 객체와 동일한 동작을 수행(서브 타입의 필드를 참조하게 되는 경우 scope 차이로 인해 에러 발생)
    - 다형성
        - 큰 범위의 다형성 - 객체 단위의 다형성(타입에 대한 다형성)
        - 작은 범위의 다형성 - 메소드 단위의 다형성
            - 오버라이딩
                - 수퍼 객체의 메소드를 서브 객체에서 재정의하여 수퍼 객체의 메소드를 서브 객체의 메소드로 형태 변화(다형성 → 실제로 힙 메모리에 선언된 메소드 정의 자체가 변화-통합 된다.)
            - 오버로딩
                - 시그니처의 변경(파라미터 변화)을 통해 같은 이름과 리턴 타입을 가진 메소드를 선언 가능 → 시그니처의 다형성(논란의 여지가 있음)

---

## 3. 객체 지향을 위한 추가적인 기능 요소

- abstract 키워드
    - 재사용이 아닌 구현의 주체를 변경
    - 주체적으로 동작을 할 수 가 없다 → 객체의 기본 정의를 만족하지 못한다(자율적인 동작) → 인스턴스화 불가능
    - 하지만 extends를 하므로 수퍼 타입에 대한 객체를 생성하여야 한다 ⇒ 오버라이드를 통해 구현되지 못한 동작을 구현하여 수퍼 객체를 보완 및 생성 가능 → 왜 추상 메소드를 꼭 구현해야 하는 가에 대한 답.
- 클래스의 static 블록 vs 생성자
    - 생성자 → 클래스 정보에서 호출되어 인스턴스를 생성하는 메소드 ⇒ 힙 영역에 객체가 생성되면서 동시에 진행 되는 동작 정의
    - static 블록 → 스택 영역에 클래스 멤버 정보가 저장되면서 동시에 진행되는 동작 정의
        - 정확하게 언제 static 블록이 호출 되는 가?
            - 클래스로더의 동작으로 결정된다. → 클래스 로드 시점은 동적으로 결정된다.
                1. 로드타임 동적 로딩(load-time dynamic loading)과 런타임 동적 로딩(run-time dynamic loading)
                2. 메인 함수 수행을 위하여 메인 함수가 포함된 클래스는 최우선으로 로딩 발생
                3. 메인 함수 수행
                4. 스태틱 영역에 대한 호출이 발생하면 해당 호출에 대한 클래스를 메모리로 로드(런타임 동적 로딩)
                5. 해당 클래스의 동작을 위한 다른 클래스들(상속 및 참조 대상 클래스)을 메모리로 로드(로드 타임 동적 로딩)
                6. 스태틱 영역으로 할당되는 과정에서 static 블록을 수행 - 필드 먼저 할당, static 블록 할당 및 수행
                7. 생성자로 해당 클래스가 인스턴스화 될 때 혹은 리플렉션 등으로 class 정보 접근 발생 혹은 정적 메소드 호출 시 수행된다.
                - 주의! static 블록은 스태틱 영역에 클래스가 로딩 될 때 한번만 수행된다. 여러번 호출 발생해도 이전에 수행되었다면 이미 스택영역에 할당 된 상태이므로 다시 호출되지 않는다. 호출 방법도 없다!
                - Enum의 경우 Enum 인스턴스 호출시 런타임 동적 로딩 수행. 전체 Enum 인스턴스에 대해 static 블록이 수행되지 않고 내부적으로 인스턴스들을 모두 생성하고, 딱 한번 마지막으로 호출된다.
